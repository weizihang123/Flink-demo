package com.guogan.wordCount.chapter04;

import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.datastream.WindowedStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;

/**
 * @author weixu
 * @create 2020-09-19 23:21
 */
public class Flink01_Window_TimeWindow {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // 1.
        DataStreamSource<String> socketDS = env.socketTextStream("localhost", 9999);

        // TODO 开窗
        // DataStream可以直接调用开窗的方法，但是都带"all",这种情况下所有 数据不分组，都在窗口里
//        socketDS.windowAll();
//        socketDS.countWindowAll();
//        socketDS.timeWindowAll();


        KeyedStream<Tuple2<String, Integer>, String> dataKS = socketDS
                .map(new MapFunction<String, Tuple2<String, Integer>>() {
                    @Override
                    public Tuple2<String, Integer> map(String value) throws Exception {
                        return Tuple2.of(value, 1);
                    }
                })
                .keyBy(r -> r.f0);
        WindowedStream<Tuple2<String, Integer>, String, TimeWindow> dataWS = dataKS.timeWindow(Time.seconds(5));
        // 滚动窗口 => 传一个参数： 窗口长度
//                .window(TumblingProcessingTimeWindows.of(Time.seconds(5)));
//                .timeWindow(Time.seconds(5), Time.seconds(2)); // 滑动窗口 => 传两个参数： 第一个是 窗口长度 ； 第二个是 滑动步长
//                .window(SlidingProcessingTimeWindows.of(Time.seconds(5), Time.seconds(2));
//                .window(ProcessingTimeSessionWindows.withGap(Time.seconds(3)));
        dataWS.sum(1).print();
        env.execute();
    }
}

package com.guogan.wordCount.chapter04;

import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;

/**
 * @author weixu
 * @create 2020-09-19 23:25
 */
public class Flink02_Window_CountWindow {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // 1.
        DataStreamSource<String> socketDS = env.socketTextStream("localhost", 9999);

        // TODO 开窗
        // DataStream可以直接调用开窗的方法，但是都带"all",这种情况下所有 数据不分组，都在窗口里
//        socketDS.windowAll();
//        socketDS.countWindowAll();
//        socketDS.timeWindowAll();


        KeyedStream<Tuple2<String, Integer>, String> dataKS = socketDS
                .map(new MapFunction<String, Tuple2<String, Integer>>() {
                    @Override
                    public Tuple2<String, Integer> map(String value) throws Exception {
                        return Tuple2.of(value, 1);
                    }
                })
                .keyBy(r -> r.f0);

        // TODO CountWindow
        // 根据 本组 数据条数 => 因为是 keyby之后开的窗
        // 在滑动窗口中，一个数据能属于多少个窗口？ => 窗口长度 / 滑动步长
        // 在滑动窗口中，每经过一个滑动步长，就会触发一个窗口的计算
        dataKS
//                .countWindow(3) // 滚动窗口：一个参数，是窗口大小
                .countWindow(3,2) // 滑动窗口: 两个参数，第一个是窗口长度，第二个是滑动步长
                .sum(1)
                .print();

        env.execute();
    }
}


package com.guogan.wordCount.chapter04;

import com.guogan.wordCount.Bean.WaterSensor;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.timestamps.AscendingTimestampExtractor;
import org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.util.Collector;

/**
 * @author weixu
 * @create 2020-09-19 23:34
 */
public class Flink03_TimeCharacteristic_EventTime {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
        // TODO 2.指定如何 从数据中 抽取出 事件时间，时间单位是 ms
        .assignTimestampsAndWatermarks(
                new AscendingTimestampExtractor<WaterSensor>() {
                    @Override
                    public long extractAscendingTimestamp(WaterSensor waterSensor) {
                        return waterSensor.getTs()*1000L;
                    }
                }
        );
        sensorDS.keyBy(data->data.getId())
                .timeWindow(Time.seconds(5))
                /**
                 * 全窗口函数：整个窗口的本组数据，存起来，关窗的时候一次性一起计算
                 */
                .process(
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {
                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> iterable, Collector<Long> collector) throws Exception {
                                collector.collect(iterable.spliterator().estimateSize());
                            }
                        }
                ).print();
        env.execute();
    }
}


package com.guogan.wordCount.chapter04;

import com.guogan.wordCount.Bean.WaterSensor;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.util.Collector;

/**
 * @author weixu
 * @create 2020-09-20 11:48
 */
public class Flink04_TimeCharacteristic_ProcessingTime {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // TODO 1.env指定时间语义
//        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                });
        sensorDS.keyBy(data->data.getId())
                .timeWindow(Time.seconds(5))
                .process(
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {
                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> iterable, Collector<Long> collector) throws Exception {
                                collector.collect(iterable.spliterator().estimateSize());
                            }
                        }
                ).print();
        env.execute();
    }
}


package com.guogan.wordCount.chapter04;

import com.guogan.wordCount.Bean.WaterSensor;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.timestamps.AscendingTimestampExtractor;
import org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.util.Collector;

/**
 * @author weixu
 * @create 2020-09-20 12:00
 */
public class Flink05_TimeCharacteristic_WindowAssigner {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                // TODO 2.指定如何 从数据中 抽取出 事件时间，时间单位是 ms
                .assignTimestampsAndWatermarks(
                        new AscendingTimestampExtractor<WaterSensor>() {
                            @Override
                            public long extractAscendingTimestamp(WaterSensor waterSensor) {
                                return waterSensor.getTs() * 1000L;
                            }
                        }
                );

        // 分组、开窗、聚合
        // TODO 窗口是如何分配的？ 开始时间、结束时间
        // 窗口的开始时间 => timestamp - (timestamp + windowSize) % windowSize;
        //              => 1549044122 - (1549044122 + 5) % 5  = 1549044120 => 向下取整（整：窗口长度的整数倍）
        //              => 1549044127 - (1549044127 + 5) % 5  = 1549044125
        // 窗口的结束时间 => start + size => 窗口的开始时间 + 窗口长度
        // 窗口是 左闭右开  =>  maxTimestamp = end - 1; =》

        // TODO 窗口是如何触发计算的？
        // window.maxTimestamp() <= ctx.getCurrentWatermark()
        // end - 1 <= watermark
        sensorDS.keyBy(data->data.getId())
                .timeWindow(Time.seconds(5))
                .process(
                        /**
                         * 全窗口函数：整个窗口的本组数据，存起来，关窗的时候一次性一起计算
                         */
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {
                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> iterable, Collector<Long> collector) throws Exception {
                                collector.collect(iterable.spliterator().estimateSize());
                            }
                        }
                ).print();
        env.execute();
        /**
         *
         */
    }
}


/**
 * @author weixu
 * @create 2020-09-20 12:08
 */
public class Flink06_Watermark_Ascending {
    public static void main(String[] args) throws Exception {
// 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
        // TODO 2.指定如何 从数据中 抽取出 事件时间，时间单位是 ms
        // Ascending是官方提供的一个抽象类，适用于 数据的 事件时间 是 单调递增 的情况
        // new Watermark(currentTimestamp == Long.MIN_VALUE ? Long.MIN_VALUE : currentTimestamp - 1);
        // 升序的场景下，watermark = eventtime - 1ms
        .assignTimestampsAndWatermarks(
                new AscendingTimestampExtractor<WaterSensor>() {
                    @Override
                    public long extractAscendingTimestamp(WaterSensor waterSensor) {
                        return waterSensor.getTs()*1000L;
                    }
                }
        );
        //分组，开创。聚合
        sensorDS.keyBy(data->data.getId())
                .timeWindow(Time.seconds(5))
                .process(
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {
                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> iterable, Collector<Long> collector) throws Exception {
                                collector.collect(iterable.spliterator().estimateSize());
                            }
                        }
                ).print();
        env.execute();
    }
}


/**
 * @author weixu
 * @create 2020-09-20 12:18
 */
public class Flink07_Watermark_OutOfOrderness {
    public static void main(String[] args) throws Exception {


        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

                // TODO 1.env指定时间语义
                        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                // TODO 2.指定如何 从数据中 抽取出 事件时间，时间单位是 ms
                // 官方提供了一个 BoundedOutOfOrdernessTimestampExtractor 乱序下 提取 事件时间 和 生成 watermark的 抽象类
                // 第一个，需要 重写 extractTimestamp => 如何 从数据中 抽取出 事件时间
                // 第二个，传参 => 最大乱序程序，是一个等待时间


                // 乱序 => 时间大的先到了，
                // 假设数据是 1，2，3，4，5，6 秒生成的，开3s的滚动窗口 [0,3),[3,6),[6,9)
                // 来的数据是 1，6，3，2，4，5 =》 最大乱序程度是 4s
                // => 等4s再关窗 => [0,3) 本应该在 ET >= 3s 时关窗 =》 等待之后，就是 7s 关窗
                // => Watermark表示时间进展、触发窗口的计算、关窗 => 也就是说 wm = 3s时，[0,3)关闭并计算
                // => watermark = EventTime - awaitTime = 7 - 4 = 3s
                // => 为了单调递增 ，上面公式的 EventTime，应该是当前为止，最大的时间戳

                // 最好是 等待多久？ => 最大乱序时间
                // 工作中，最大乱序时间 => 对数据进行抽样、进行估算 => 靠经验
                // 如果数据乱序程度达到 1小时 => 真的要等 1个小时吗？
                .assignTimestampsAndWatermarks(
                        new BoundedOutOfOrdernessTimestampExtractor<WaterSensor>(Time.seconds(3)) {
                            @Override
                            public long extractTimestamp(WaterSensor waterSensor) {
                                return waterSensor.getTs() * 1000L;
                            }
                        }
                );
        sensorDS.keyBy(data->data.getId())
                .timeWindow(Time.seconds(5))
                .process(
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {
                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> iterable, Collector<Long> collector) throws Exception {
                                collector.collect(iterable.spliterator().estimateSize());
                            }
                        }
                ).print();
        env.execute();
    }
}


/**
 * @author weixu
 * @create 2020-09-21 18:31
 */
public class Flink08_Watermark_Periodic {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        //TODO 设置 周期性 生成 Watermark的时间间隔，默认200ms，一般不改动
//        env.getConfig().setAutoWatermarkInterval(5000L);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new AssignerWithPeriodicWatermarks<WaterSensor>() {
                            private Long maxTS=Long.MIN_VALUE;
                            @Nullable
                            @Override
                            public Watermark getCurrentWatermark() {
                                System.out.println("periodic..");
                                return new Watermark(maxTS);
                            }

                            @Override
                            public long extractTimestamp(WaterSensor waterSensor, long l) {
                                maxTS=Math.max(maxTS,waterSensor.getTs()*1000L);
                                return waterSensor.getTs()*1000L;
                            }
                        }
                );
        sensorDS.keyBy(data->data.getId())
                .timeWindow(Time.seconds(5))
                .process(
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {
                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> iterable, Collector<Long> collector) throws Exception {
                                collector.collect(iterable.spliterator().estimateSize());
                            }
                        }
                ).print();
        env.execute();
    }
}


package com.guogan.wordCount.chapter04;

import com.guogan.wordCount.Bean.WaterSensor;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.AssignerWithPunctuatedWatermarks;
import org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;
import org.apache.flink.streaming.api.watermark.Watermark;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.util.Collector;

import javax.annotation.Nullable;

/**
 * @author weixu
 * @create 2020-09-21 18:45
 */
public class Flink09_Watermark_Punctuated {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        //TODO 设置 周期性 生成 Watermark的时间间隔，默认200ms，一般不改动
//        env.getConfig().setAutoWatermarkInterval(5000L);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new AssignerWithPunctuatedWatermarks<WaterSensor>() {
                            private Long MaxTS=Long.MIN_VALUE;
                            @Nullable
                            @Override
                            public Watermark checkAndGetNextWatermark(WaterSensor waterSensor, long l) {
                                return new Watermark(MaxTS);
                            }

                            @Override
                            public long extractTimestamp(WaterSensor waterSensor, long l) {
                                MaxTS=Math.max(MaxTS,waterSensor.getTs()*1000L);
                                return waterSensor.getTs()*1000L;
                            }
                        }
                );
        sensorDS.keyBy(data->data.getId())
                .timeWindow(Time.seconds(5))
                .process(
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {
                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> iterable, Collector<Long> collector) throws Exception {
                                collector.collect(iterable.spliterator().estimateSize());
                            }
                        }
                ).print();
        env.execute();
    }
}


/**
 * @author weixu
 * @create 2020-09-21 18:57
 */
public class Flink10_Watermark_FileIssue {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // TODO 对于有界流：文件，为了保证所有的数据都被计算，Flink会在最后，给一个Long的最大值的Watermark，保证所有窗口都被触发计算
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
//                .readTextFile("input/sensor-data.log")
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new AscendingTimestampExtractor<WaterSensor>() {
                            @Override
                            public long extractAscendingTimestamp(WaterSensor waterSensor) {
                                return waterSensor.getTs()*1000L;
                            }
                        }
                );
        sensorDS.keyBy(data->data.getId())
                .timeWindow(Time.seconds(5))
                .process(
                        new ProcessWindowFunction<WaterSensor, String, String, TimeWindow>() {
                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> elements, Collector<String> collector) throws Exception {
                                collector.collect("当前key=" + s
                                        + ",watermark=" + context.currentWatermark()
                                        + "一共有" + elements.spliterator().estimateSize() + "条数据");
                            }
                        }
                ).print();
        env.execute();
    }
}


/**
 * @author weixu
 * @create 2020-09-21 19:07
 */
public class Flink11_Watermark_AllowedLateness {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new BoundedOutOfOrdernessTimestampExtractor<WaterSensor>(Time.seconds(3)) {
                            @Override
                            public long extractTimestamp(WaterSensor waterSensor) {
                                return waterSensor.getTs()*1000L;
                            }
                        }
                );
        // 分组、开窗、聚合
        //TODO 处理迟到的数据： 窗口再等一会
        // 1.当watermark >= 窗口结束时间的时候，会正常触发计算，但是，不会关闭窗口
        // 2.当watermark >= 窗口结束时间 + 窗口等待时间，会真正的关闭窗口
        // 2.当 窗口结束时间 <= watermark <= 窗口结束时间 + 窗口等待时间,每来一条迟到数据，就会计算一次
        OutputTag<WaterSensor> output = new OutputTag<WaterSensor>("output"){};

        sensorDS.keyBy(data->data.getId())
                .timeWindow(Time.seconds(5))
                .allowedLateness(Time.seconds(2))
                .sideOutputLateData(output)
                .process(
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {
                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> iterable, Collector<Long> collector) throws Exception {
                                collector.collect(iterable.spliterator().estimateSize());
                            }
                        }
                ).print();
        sensorDS.getSideOutput(output).print("outpur...");
        env.execute();
    }
}


/**
 * TODO
 *
 * @author cjp
 * @version 1.0
 * @date 2020/9/19 11:22
 */
public class Flink12_Watermark_SideOutput {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new BoundedOutOfOrdernessTimestampExtractor<WaterSensor>(Time.seconds(3)){
                            @Override
                            public long extractTimestamp(WaterSensor element) {
                                return element.getTs() * 1000L;
                            }
                        }
                );


        // 分组、开窗、聚合
        //TODO 处理迟到的数据： 真正关窗之后的 迟到数据，放到一个 侧输出流 里
        // 1.当watermark >= 窗口结束时间的时候，会正常触发计算，但是，不会关闭窗口
        // 2.当watermark >= 窗口结束时间 + 窗口等待时间，会真正的关闭窗口
        // 2.当 窗口结束时间 <= watermark <= 窗口结束时间 + 窗口等待时间,每来一条迟到数据，就会计算一次
        OutputTag<WaterSensor> outputTag = new OutputTag<WaterSensor>("late data"){};

        SingleOutputStreamOperator<Long> resultDS = sensorDS
                .keyBy(data -> data.getId())
                .timeWindow(Time.seconds(5))
                .allowedLateness(Time.seconds(2))
                .sideOutputLateData(outputTag)
                .process(
                        /**
                         * 全窗口函数：整个窗口的本组数据，存起来，关窗的时候一次性一起计算
                         */
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {

                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> elements, Collector<Long> out) throws Exception {
                                out.collect(elements.spliterator().estimateSize());
                            }
                        });

        resultDS.getSideOutput(outputTag).print("late data in side-output");
        resultDS.print("result");

        env.execute();
    }
}


/**
 * @author weixu
 * @create 2020-09-21 19:23
 */
public class Flink13_Watermark_Parallalism {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        // TODO 并行度对watermark的影响 => 以最小的为准
        env.setParallelism(2);

        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new BoundedOutOfOrdernessTimestampExtractor<WaterSensor>(Time.seconds(3)){
                            @Override
                            public long extractTimestamp(WaterSensor element) {
                                return element.getTs() * 1000L;
                            }
                        }
                );



        SingleOutputStreamOperator<Long> resultDS = sensorDS
                .keyBy(data -> data.getId())
                .timeWindow(Time.seconds(5))
                .process(
                        /**
                         * 全窗口函数：整个窗口的本组数据，存起来，关窗的时候一次性一起计算
                         */
                        new ProcessWindowFunction<WaterSensor, Long, String, TimeWindow>() {

                            @Override
                            public void process(String s, Context context, Iterable<WaterSensor> elements, Collector<Long> out) throws Exception {
                                out.collect(elements.spliterator().estimateSize());
                            }
                        });

        resultDS.print("result");

        env.execute();
    }
}


/**
 * @author weixu
 * @create 2020-09-21 19:24
 */
public class Flink14_ProcessFunction_Keyed {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        DataStreamSource<String> inputDS = env.socketTextStream("localhost", 9999);
        SingleOutputStreamOperator<WaterSensor> sensorDS = inputDS.map(new MapFunction<String, WaterSensor>() {
            @Override
            public WaterSensor map(String s) throws Exception {
                String[] datas = s.split(",");

                return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));
            }
        })
                .assignTimestampsAndWatermarks(
                        new AssignerWithPunctuatedWatermarks<WaterSensor>() {
                            private Long maxTS=Long.MIN_VALUE;
                            @Nullable
                            @Override
                            public Watermark checkAndGetNextWatermark(WaterSensor waterSensor, long l) {
                                return new Watermark(maxTS);
                            }

                            @Override
                            public long extractTimestamp(WaterSensor waterSensor, long l) {
                                maxTS=Math.max(maxTS,waterSensor.getTs()*1000L);
                                return waterSensor.getTs()*1000L;
                            }
                        }
                );
        sensorDS.keyBy(data->data.getId())
                .process(
                        new KeyedProcessFunction<String, WaterSensor, Long>() {
                            private Long tiggerTS=0L;
                            @Override
                            public void processElement(WaterSensor value, Context context, Collector<Long> collector) throws Exception {
                                if (tiggerTS==0){
                                    context.timerService().registerEventTimeTimer(
                                          value.getTs()*1000L+5000L
                                    );
                                    tiggerTS=value.getTs()*1000L+5000L;
                                }
                            }
                            @Override
                            public void onTimer(long timestamp, OnTimerContext ctx, Collector<Long> out) throws Exception {
//                                System.out.println(new Timestamp(timestamp) + "定时器触发");
                                System.out.println(timestamp + "定时器触发");
                            }

                        }
                ).print();
        env.execute();
    }
}


/**
 * 连续5s水位上升进行告警
 *
 * @author
 * @version 1.0
 * @date 2020/9/19 11:22
 */
public class Flink15_ProcessFunction_TimerPractice {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new AssignerWithPunctuatedWatermarks<WaterSensor>() {
                            private Long maxTs = Long.MIN_VALUE;

                            @Nullable
                            @Override
                            public Watermark checkAndGetNextWatermark(WaterSensor lastElement, long extractedTimestamp) {
                                maxTs = Math.max(maxTs, extractedTimestamp);
                                return new Watermark(maxTs);
                            }

                            @Override
                            public long extractTimestamp(WaterSensor element, long previousElementTimestamp) {
                                return element.getTs() * 1000L;
                            }
                        }
                );
        sensorDS.keyBy(data->data.getId())
                .process(
                        new KeyedProcessFunction<String, WaterSensor, String>() {
                            private Integer lastVS = 0;
                            private Long trggerTS = 0L;

                            @Override
                            public void processElement(WaterSensor waterSensor, Context context, Collector<String> collector) throws Exception {
                                if (waterSensor.getVc() >= lastVS) {
                                    if (trggerTS == 0) {
                                        context.timerService().registerEventTimeTimer(waterSensor.getTs() * 1000L + 5000L);
                                        trggerTS = waterSensor.getTs() * 1000L + 5000L;
                                    }
                                } else {
                                    context.timerService().deleteEventTimeTimer(trggerTS);
                                    trggerTS = 0L;
                                }
                                lastVS = waterSensor.getVc();

                            }

                            @Override
                            public void onTimer(long timestamp, KeyedProcessFunction<String, WaterSensor, String>.OnTimerContext ctx, Collector<String> out) throws Exception {
                                // 定时器触发，说明已经满足 连续5s 水位上升
                                out.collect(ctx.getCurrentKey() + "在" + timestamp + "监测到水位连续5s上升");
                                // 将保存的注册时间清空
                                trggerTS = 0L;
                            }
                        }
                ).print();
        env.execute();

    }
}



/**
 * @author weixu
 * @create 2020-09-21 20:17
 */
public class Flink16_ProcessFunction_SideOutput {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new AssignerWithPunctuatedWatermarks<WaterSensor>() {
                            private Long maxTs = Long.MIN_VALUE;

                            @Nullable
                            @Override
                            public Watermark checkAndGetNextWatermark(WaterSensor lastElement, long extractedTimestamp) {
                                maxTs = Math.max(maxTs, extractedTimestamp);
                                return new Watermark(maxTs);
                            }

                            @Override
                            public long extractTimestamp(WaterSensor element, long previousElementTimestamp) {
                                return element.getTs() * 1000L;
                            }
                        }
                );
        //TODO 使用侧输出流
        // 1.定义一个OutputTag，给定一个 名称
        // 2.使用 ctx.output(outputTag对象,放入侧输出流的数据)
        // 3.获取侧输出流 => DataStream.getSideOutput(outputTag对象)
        OutputTag<String> outputTag = new OutputTag<String>("output"){};
        SingleOutputStreamOperator<WaterSensor> process = sensorDS.keyBy(data -> data.getId())
                .process(
                        new KeyedProcessFunction<String, WaterSensor, WaterSensor>() {
                            @Override
                            public void processElement(WaterSensor waterSensor, Context context, Collector<WaterSensor> collector) throws Exception {
                                if (waterSensor.getVc() >= 5) {
                                    context.output(outputTag, "水位高于5.。 ");
                                }
                                collector.collect(waterSensor);
                            }
                        }
                );
        process.print();
        process.getSideOutput(outputTag).print("output");
        env.execute();
    }
}


package com.guogan.wordCount.chapter04;

import com.guogan.wordCount.Bean.WaterSensor;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.checkpoint.ListCheckpointed;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.AssignerWithPunctuatedWatermarks;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.streaming.api.watermark.Watermark;
import org.apache.flink.util.Collector;
import org.apache.flink.util.OutputTag;

import javax.annotation.Nullable;
import java.util.List;

/**
 * 水位高于 阈值 通过 侧输出流 告警
 * @author weixu
 * @create 2020-09-21 20:45
 */
public class Flink17_State_Operator {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MyMapFunction())
                .assignTimestampsAndWatermarks(
                        new AssignerWithPunctuatedWatermarks<WaterSensor>() {
                            private Long maxTs = Long.MIN_VALUE;

                            @Nullable
                            @Override
                            public Watermark checkAndGetNextWatermark(WaterSensor lastElement, long extractedTimestamp) {
                                maxTs = Math.max(maxTs, extractedTimestamp);
                                return new Watermark(maxTs);
                            }

                            @Override
                            public long extractTimestamp(WaterSensor element, long previousElementTimestamp) {
                                return element.getTs() * 1000L;
                            }
                        }
                );

        //TODO 使用侧输出流
        // 1.定义一个OutputTag，给定一个 名称
        // 2.使用 ctx.output(outputTag对象,放入侧输出流的数据)
        // 3.获取侧输出流 => DataStream.getSideOutput(outputTag对象)
        OutputTag<String> outputTag = new OutputTag<String>("vc alarm") {
        };

        SingleOutputStreamOperator<WaterSensor> processDS = sensorDS
                .keyBy(data -> data.getId())
                .process(
                        new KeyedProcessFunction<String, WaterSensor, WaterSensor>() {

                            /**
                             * 来一条数据，处理一条
                             * @param value
                             * @param ctx
                             * @param out
                             * @throws Exception
                             */
                            @Override
                            public void processElement(WaterSensor value, Context ctx, Collector<WaterSensor> out) throws Exception {
                                if (value.getVc() > 5) {
                                    // 水位高于阈值，用侧输出流告警
                                    ctx.output(outputTag, "水位高于阈值5！！！");
                                }
                                out.collect(value);
                            }
                        }
                );


        processDS.print();
        processDS.getSideOutput(outputTag).print("alarm");

        env.execute();
    }


    public static class MyMapFunction implements MapFunction<String, WaterSensor>, ListCheckpointed<String> {
        @Override
        public WaterSensor map(String value) throws Exception {
            String[] datas = value.split(",");
            return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

        }

        @Override
        public List<String> snapshotState(long checkpointId, long timestamp) throws Exception {
            return null;
        }

        @Override
        public void restoreState(List<String> state) throws Exception {

        }

    }
}



import com.guogan.wordCount.Bean.WaterSensor;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.common.state.*;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.AssignerWithPunctuatedWatermarks;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.streaming.api.watermark.Watermark;
import org.apache.flink.util.Collector;

import javax.annotation.Nullable;

/**
 * @author weixu
 * @create 2020-09-21 20:48
 */
public class Flink18_State_KeyedDemo {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new AssignerWithPunctuatedWatermarks<WaterSensor>() {
                            private Long maxTs = Long.MIN_VALUE;

                            @Nullable
                            @Override
                            public Watermark checkAndGetNextWatermark(WaterSensor lastElement, long extractedTimestamp) {
                                maxTs = Math.max(maxTs, extractedTimestamp);
                                return new Watermark(maxTs);
                            }

                            @Override
                            public long extractTimestamp(WaterSensor element, long previousElementTimestamp) {
                                return element.getTs() * 1000L;
                            }
                        }
                );
        sensorDS.keyBy(data->data.getId())
                .process(
                        new KeyedProcessFunction<String, WaterSensor, WaterSensor>() {
                            ValueState<Integer> valueState;
                            ListState<String> listState;
                            MapState<String,String> mapState;
                            @Override
                            public void open(Configuration parameters) throws Exception{
                                valueState=getRuntimeContext().getState(new ValueStateDescriptor<Integer>("valuestate",Integer.class));
                                listState=getRuntimeContext().getListState(new ListStateDescriptor<String>("liststate",String.class));
                                mapState=getRuntimeContext().getMapState(new MapStateDescriptor<String, String>("mapstate",String.class,String.class));
                            }
                            @Override
                            public void processElement(WaterSensor waterSensor, Context context, Collector<WaterSensor> collector) throws Exception {
                                valueState.value(); // 取出值
//                                valueState.update(); // 更新值
//                                valueState.clear();

//                                listState.add();    // 添加单个值
//                                listState.addAll(); //添加整个List
//                                Iterator<String> iterator = listState.get().iterator();
//                                while(iterator.hasNext()){
//                                    iterator.next();
//                                }
//                                listState.update(); // 更新整个集合
//                                listState.clear();

//                                mapState.put(); // 添加单个 k-v 对
//                                mapState.putAll();  // 添加整个Map
//                                mapState.get(); // 根据key，获取value
//                                mapState.contains();
//                                mapState.remove();
//                                mapState.clear();
                            }
                        }
                ).print();
        env.execute();
    }
}


/**
 * 连续5s水位上升进行告警
 * @author weixu
 * @create 2020-09-21 21:05
 */
public class Flink19_State_Keyed {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new AssignerWithPunctuatedWatermarks<WaterSensor>() {
                            private Long maxTs = Long.MIN_VALUE;

                            @Nullable
                            @Override
                            public Watermark checkAndGetNextWatermark(WaterSensor lastElement, long extractedTimestamp) {
                                maxTs = Math.max(maxTs, extractedTimestamp);
                                return new Watermark(maxTs);
                            }

                            @Override
                            public long extractTimestamp(WaterSensor element, long previousElementTimestamp) {
                                return element.getTs() * 1000L;
                            }
                        }
                );


        SingleOutputStreamOperator<String> processDS = sensorDS
                .keyBy(data -> data.getId())
                .process(
                        new KeyedProcessFunction<String, WaterSensor, String>() {

                            // 定义一个变量，保存上一次的水位值
                            private ValueState<Integer> lastVC;

                            @Override
                            public void open(Configuration parameters) throws Exception {
                                lastVC = getRuntimeContext().getState(new ValueStateDescriptor<Integer>("lastVC", Integer.class));
                            }

                            /**
                             * 来一条数据，处理一条
                             * @param value
                             * @param ctx
                             * @param out
                             * @throws Exception
                             */
                            @Override
                            public void processElement(WaterSensor value, Context ctx, Collector<String> out) throws Exception {
                                out.collect("当前数据所属的key=" + ctx.getCurrentKey() + ",保存的上一次水位值是=" + lastVC.value());
                                lastVC.update(value.getVc());
                            }
                        }
                );


        processDS.print();

        env.execute();
    }
}

/**
 * @author weixu
 * @create 2020-09-21 21:16
 */
public class Flink20_State_TimerPractice {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        // TODO 1.env指定时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.
        SingleOutputStreamOperator<WaterSensor> sensorDS = env
                .socketTextStream("localhost", 9999)
                .map(new MapFunction<String, WaterSensor>() {
                    @Override
                    public WaterSensor map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new WaterSensor(datas[0], Long.valueOf(datas[1]), Integer.valueOf(datas[2]));

                    }
                })
                .assignTimestampsAndWatermarks(
                        new AssignerWithPunctuatedWatermarks<WaterSensor>() {
                            private Long maxTs = Long.MIN_VALUE;

                            @Nullable
                            @Override
                            public Watermark checkAndGetNextWatermark(WaterSensor lastElement, long extractedTimestamp) {
                                maxTs = Math.max(maxTs, extractedTimestamp);
                                return new Watermark(maxTs);
                            }

                            @Override
                            public long extractTimestamp(WaterSensor element, long previousElementTimestamp) {
                                return element.getTs() * 1000L;
                            }
                        }
                );


        SingleOutputStreamOperator<String> processDS = sensorDS
                .keyBy(data -> data.getId())
                .process(
                        new KeyedProcessFunction<String, WaterSensor, String>() {

                            // 定义一个变量，保存上一次的水位值
                            private ValueState<Integer> lastVC;
                            private ValueState<Long> triggerTs;

                            @Override
                            public void open(Configuration parameters) throws Exception {
                                lastVC = getRuntimeContext().getState(new ValueStateDescriptor<Integer>("lastVC", Integer.class, 0));
                                triggerTs = getRuntimeContext().getState(new ValueStateDescriptor<Long>("triggerTs", Long.class));
                            }

                            /**
                             * 来一条数据，处理一条
                             * @param value
                             * @param ctx
                             * @param out
                             * @throws Exception
                             */
                            @Override
                            public void processElement(WaterSensor value, Context ctx, Collector<String> out) throws Exception {
                                // 判断是上升还是下降
                                if (value.getVc() > lastVC.value()) {
                                    // 1.水位上升
                                    if (triggerTs.value() == null) {
                                        // 第一条数据来的时候，注册定时器
                                        ctx.timerService().registerEventTimeTimer(value.getTs() * 1000L + 5000L);
                                        triggerTs.update(value.getTs() * 1000L + 5000L);
                                    }
                                } else {
                                    // 2.水位下降
                                    // 2.1 删除注册的定时器
                                    ctx.timerService().deleteEventTimeTimer(triggerTs.value());
                                    // 2.2 重新注册定时器（或 把保存的时间清空）
                                    triggerTs.clear();
                                }

                                // 不管上升还是下降，都要保存水位值，供下条数据使用，进行比较
                                lastVC.update(value.getVc());
                            }

                            /**
                             * 定时器触发
                             * @param timestamp 注册的定时器的时间
                             * @param ctx   上下文
                             * @param out   采集器
                             * @throws Exception
                             */
                            @Override
                            public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {
                                // 定时器触发，说明已经满足 连续5s 水位上升
                                out.collect(ctx.getCurrentKey() + "在" + timestamp + "监测到水位连续5s上升,当前watermark=" + ctx.timerService().currentWatermark()
                                        + ",当前保存水位的状态=" + lastVC.value());
                                // 将保存的注册时间清空
                                triggerTs.clear();
                            }
                        }
                );


        processDS.print();

        env.execute();
    }
}


/**
 * @author weixu
 * @create 2020-09-23 9:49
 */
public class Flink24_Case_UVWithWindow {
    public static void main(String[] args) throws Exception {

        // 0.创建执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.从文件读取数据、转换成 bean对象
        SingleOutputStreamOperator<UserBehavior> userBehaviorDS = env
                .readTextFile("input/UserBehavior.csv")
                .map(new MapFunction<String, UserBehavior>() {

                    @Override
                    public UserBehavior map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new UserBehavior(
                                Long.valueOf(datas[0]),
                                Long.valueOf(datas[1]),
                                Integer.valueOf(datas[2]),
                                datas[3],
                                Long.valueOf(datas[4])
                        );
                    }
                })
                .assignTimestampsAndWatermarks(
                        new AscendingTimestampExtractor<UserBehavior>() {
                            @Override
                            public long extractAscendingTimestamp(UserBehavior element) {
                                return element.getTimestamp() * 1000L;
                            }
                        }
                );

        SingleOutputStreamOperator<Tuple2<String, Long>> uvTuple = userBehaviorDS.filter(r -> "pv".equals(r.getBehavior())).map(
                new MapFunction<UserBehavior, Tuple2<String, Long>>() {
                    @Override
                    public Tuple2<String, Long> map(UserBehavior userBehavior) throws Exception {
                        return Tuple2.of("uv", userBehavior.getUserId());
                    }
                }
        );
        WindowedStream<Tuple2<String, Long>, String, TimeWindow> uvWS = uvTuple.keyBy(f -> f.f0).timeWindow(Time.hours(1));
        uvWS.process(
                new ProcessWindowFunction<Tuple2<String, Long>, Long, String, TimeWindow>() {
                    private Set<Long> uvCount = new HashSet<>();
                    @Override
                    public void process(String s, Context context, Iterable<Tuple2<String, Long>> iterable, Collector<Long> collector) throws Exception {
                        for (Tuple2<String, Long> stringLongTuple2 : iterable) {
                            uvCount.add(stringLongTuple2.f1);
                        }
                        collector.collect(Long.valueOf(uvCount.size()));
                        uvCount.clear();
                    }
                }
        ).print("uv");
        env.execute();
    }
}


/**
 * @author weixu
 * @create 2020-09-23 12:08
 */
public class Flink25_Case_HotItemsAnalysis {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.读取数据
        SingleOutputStreamOperator<UserBehavior> inputDS = env.readTextFile("input/UserBehavior.csv")
                .map(new MapFunction<String, UserBehavior>() {
                    @Override
                    public UserBehavior map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new UserBehavior(
                                Long.valueOf(datas[0]),
                                Long.valueOf(datas[1]),
                                Integer.valueOf(datas[2]),
                                datas[3],
                                Long.valueOf(datas[4]));
                    }
                })
                .assignTimestampsAndWatermarks(new AscendingTimestampExtractor<UserBehavior>() {
                    @Override
                    public long extractAscendingTimestamp(UserBehavior userBehavior) {
                        return userBehavior.getTimestamp() * 1000L;
                    }
                });
        WindowedStream<UserBehavior, Long, TimeWindow> itemKDS = inputDS.filter(r -> "pv".equals(r.getBehavior()))
                .keyBy(r -> r.getItemId()).timeWindow(Time.hours(1), Time.minutes(5));
        itemKDS.aggregate(new aggcount(),new userAggreatCount()).keyBy(r->r.getWindowEnd()).process(new topn(3) ).print();

        env.execute();

    }

    public static class topn extends KeyedProcessFunction<Long, HotItemCountWithWindowEnd, String> {
        private ListState<HotItemCountWithWindowEnd> listState;
        private ValueState<Long> triggerTS;
        private Integer treadShod;

        public topn(Integer treadShod) {
            this.treadShod = treadShod;
        }

        @Override
        public void processElement(HotItemCountWithWindowEnd value, Context context, Collector<String> collector) throws Exception {
            listState.add(value);
            if (triggerTS.value()==null){
                context.timerService().registerEventTimeTimer(value.getWindowEnd());
                triggerTS.update(value.getWindowEnd());
            }


        }
        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {
            Iterable<HotItemCountWithWindowEnd> value = listState.get();
            ArrayList<HotItemCountWithWindowEnd> count = new ArrayList<>();
            for (HotItemCountWithWindowEnd data : value) {
                count.add(data);
            }
            triggerTS.clear();
            listState.clear();
            count.sort(new Comparator<HotItemCountWithWindowEnd>() {
                @Override
                public int compare(HotItemCountWithWindowEnd o1, HotItemCountWithWindowEnd o2) {
                    return o2.getItemCount().intValue()-o1.getItemCount().intValue();
                }
            });
            StringBuilder result = new StringBuilder();
            result.append("结束时间"+timestamp+"\n");
            result.append("---------------------\n");
            for(int i=0;i<treadShod;i++){
                result.append(count.get(i)+"\n");
            }
            result.append("-----\n\n");
            out.collect(result.toString());
        }

        @Override
        public void open(Configuration parameters) throws Exception {
            listState=getRuntimeContext().getListState(new ListStateDescriptor<HotItemCountWithWindowEnd>("liststate",HotItemCountWithWindowEnd.class));
            triggerTS=getRuntimeContext().getState(new ValueStateDescriptor<Long>("trigger",Long.class));
        }
    }
    public static class userAggreatCount extends ProcessWindowFunction<Long,HotItemCountWithWindowEnd,Long,TimeWindow>{
        @Override
        public void process(Long key, Context context, Iterable<Long> iterable, Collector<HotItemCountWithWindowEnd> collector) throws Exception {
            collector.collect(new HotItemCountWithWindowEnd(
                    key,iterable.iterator().next(),context.window().getEnd()
            ));
        }

    }
    public static class aggcount implements AggregateFunction<UserBehavior,Long,Long>{
        @Override
        public Long createAccumulator() {
            return 0L;
        }

        @Override
        public Long add(UserBehavior userBehavior, Long aLong) {
            return aLong+1L;
        }

        @Override
        public Long getResult(Long aLong) {
            return aLong;
        }

        @Override
        public Long merge(Long a, Long b) {
            return a+b;
        }
    }

}

/**
 * 每隔5秒，输出最近10分钟内访问量最多的前N个URL
 * @author weixu
 * @create 2020-09-23 19:21
 */
public class Flink26_Case_HotPageViewAnalysis {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        DataStreamSource<String> inputDS = env.readTextFile("input/apache.log");
        SingleOutputStreamOperator<ApacheLog> apacheLogDS = inputDS.map(new MapFunction<String, ApacheLog>() {

            @Override
            public ApacheLog map(String value) throws Exception {
                String[] datas = value.split(" ");
                SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy:HH:mm:ss");
                Date date = dateFormat.parse(datas[3]);
                long ts = date.getTime();
                return new ApacheLog(
                        datas[0],
                        datas[1],
                        ts,
                        datas[5],
                        datas[6]
                );
            }
        }).assignTimestampsAndWatermarks(
                new AscendingTimestampExtractor<ApacheLog>() {
                    @Override
                    public long extractAscendingTimestamp(ApacheLog apacheLog) {
                        return apacheLog.getEventTime();
                    }
                }
        );
        apacheLogDS.keyBy(new KeySelector<ApacheLog, String>() {
            @Override
            public String getKey(ApacheLog apacheLog) throws Exception {
                return apacheLog.getUrl();
            }
        }).timeWindow(Time.minutes(10),Time.seconds(5)).aggregate(new SimpleAggFunction<ApacheLog>(),new aggrecount() )
                .keyBy(r->r.getWindowEnd()).process(new topN(3)).print();
        env.execute();
    }
    public static class topN extends KeyedProcessFunction<Long, HotPageView,String>{
        private ListState<HotPageView> listState;
        private ValueState<Long> triggerTS;
        private Integer threshold;

        public topN(Integer threshold) {
            this.threshold = threshold;
        }

        @Override
        public void open(Configuration parameters) throws Exception {
            listState=getRuntimeContext().getListState(new ListStateDescriptor<HotPageView>("a",HotPageView.class));
            triggerTS=getRuntimeContext().getState(new ValueStateDescriptor<Long>("b",Long.class));

        }

        @Override
        public void processElement(HotPageView hotPageView, Context context, Collector<String> collector) throws Exception {
            listState.add(hotPageView);
            if (triggerTS.value()==null){
                context.timerService().registerEventTimeTimer(hotPageView.getWindowEnd());
            }
            triggerTS.update(hotPageView.getWindowEnd());
        }

        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {

            Iterable<HotPageView> hotPageViews = listState.get();
            ArrayList<HotPageView> list = new ArrayList<>();
            for (HotPageView data : hotPageViews) {
                list.add(data);
            }
            triggerTS.clear();
            listState.clear();
            list.sort(new Comparator<HotPageView>() {
                @Override
                public int compare(HotPageView o1, HotPageView o2) {
                    return o2.getViewCount().intValue()-o1.getViewCount().intValue();
                }
            });
            StringBuilder result = new StringBuilder();
            result.append("最后时间"+timestamp+"\n").append("------------------\n");
            threshold=threshold>list.size()?list.size():threshold;
            for (int i = 0; i < threshold; i++) {
                result.append(list.get(i)+"\n");
            }
            out.collect(result.toString());
        }
    }
    public static class aggrecount extends ProcessWindowFunction<Long, HotPageView,String, TimeWindow> {

        @Override
        public void process(String s, Context context, Iterable<Long> iterable, Collector<HotPageView> collector) throws Exception {
            collector.collect(new HotPageView(
                        s,iterable.iterator().next(),context.window().getEnd()
            ));
        }
    }
}


/**
 * 每隔5秒，输出最近10分钟内 不同省份点击最多的广告排名（）
 * @author weixu
 * @create 2020-09-23 18:13
 */
public class Flink27_Case_AdClickAnalysis {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        DataStreamSource<String> inputDS = env.readTextFile("input/AdClickLog.csv");
        SingleOutputStreamOperator<AdClickLog> adDS = inputDS.map(new MapFunction<String, AdClickLog>() {
            @Override
            public AdClickLog map(String value) throws Exception {
                String[] datas = value.split(",");
                return new AdClickLog(
                        Long.valueOf(datas[0]),
                        Long.valueOf(datas[1]),
                        datas[2],
                        datas[3],
                        Long.valueOf(datas[4])
                );
            }
        }).assignTimestampsAndWatermarks(
                new AscendingTimestampExtractor<AdClickLog>() {
                    @Override
                    public long extractAscendingTimestamp(AdClickLog adClickLog) {
                        return adClickLog.getTimestamp() * 1000L;
                    }
                }
        );
        KeyedStream<AdClickLog, Tuple2<String, Long>> adClickLogTuple2KeyedStream = adDS.keyBy(new KeySelector<AdClickLog, Tuple2<String, Long>>() {
            @Override
            public Tuple2<String, Long> getKey(AdClickLog value) throws Exception {
                return Tuple2.of(value.getProvince(), value.getAdId());
            }
        });
        adClickLogTuple2KeyedStream.timeWindow(Time.minutes(10),Time.seconds(5))
                .aggregate(new SimpleAggFunction<AdClickLog>(),new aggregateCount())
                .keyBy(r->r.getWindowEnd()).process(new topN(3)).print();

        env.execute();
    }
    public static class topN extends KeyedProcessFunction<Long, HotAdClick,String>{
        private ListState<HotAdClick> listState;
        private ValueState<Long> triggerTS;
        private Integer threshold;

        public topN(Integer threshold) {
            this.threshold = threshold;
        }

        @Override
        public void open(Configuration parameters) throws Exception {
            listState=getRuntimeContext().getListState(new ListStateDescriptor<HotAdClick>("hh",HotAdClick.class));
            triggerTS=getRuntimeContext().getState(new ValueStateDescriptor<Long>("aa",Long.class));
        }

        @Override
        public void processElement(HotAdClick value, Context context, Collector<String> collector) throws Exception {
                listState.add(value);
                if (triggerTS.value()==null){
                    context.timerService().registerEventTimeTimer(value.getWindowEnd());
                    triggerTS.update(value.getWindowEnd());
                }
        }

        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {
            List<HotAdClick> value = new ArrayList<>();
            Iterable<HotAdClick> datas = listState.get();
            for (HotAdClick data : datas) {
                value.add(data);
            }
            listState.clear();
            triggerTS.clear();
            value.sort(new Comparator<HotAdClick>() {
                @Override
                public int compare(HotAdClick o1, HotAdClick o2) {
                    return o2.getClickCount().intValue()-o1.getClickCount().intValue();
                }
            });
            StringBuilder result = new StringBuilder();
            result.append("结束时间"+timestamp+"\n")
            .append("-------------\n");
            threshold=threshold>value.size()?value.size():threshold;
            for (int i = 0; i < threshold; i++) {
                result.append(value.get(i)+"\n");
            }
            result.append("-------------\n");
            out.collect(result.toString());
        }
    }
    public static class aggregateCount extends ProcessWindowFunction<Long, HotAdClick,Tuple2<String, Long>, TimeWindow>{

        @Override
        public void process(Tuple2<String, Long> value, Context context, Iterable<Long> iterable, Collector<HotAdClick> collector) throws Exception {
            collector.collect(new HotAdClick(
                    value.f0,value.f1,iterable.iterator().next(),context.window().getEnd()
            ));
        }
    }

}


/**
 * 每隔5秒，输出最近10分钟内 不同省份点击最多的广告排名（）
 * @author weixu
 * @create 2020-09-23 18:13
 */
public class Flink28_Case_AdClickAnalysisBlackFilter {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        DataStreamSource<String> inputDS = env.readTextFile("input/AdClickLog.csv");
        SingleOutputStreamOperator<AdClickLog> adDS = inputDS.map(new MapFunction<String, AdClickLog>() {
            @Override
            public AdClickLog map(String value) throws Exception {
                String[] datas = value.split(",");
                return new AdClickLog(
                        Long.valueOf(datas[0]),
                        Long.valueOf(datas[1]),
                        datas[2],
                        datas[3],
                        Long.valueOf(datas[4])
                );
            }
        }).assignTimestampsAndWatermarks(
                new AscendingTimestampExtractor<AdClickLog>() {
                    @Override
                    public long extractAscendingTimestamp(AdClickLog adClickLog) {
                        return adClickLog.getTimestamp() * 1000L;
                    }
                }
        );

        adDS.keyBy(new KeySelector<AdClickLog, Tuple2<Long,Long>>() {
            @Override
            public Tuple2<Long, Long> getKey(AdClickLog value) throws Exception {
                return Tuple2.of(value.getUserId(),value.getAdId());
            }
        }) .process(new adFilter() ).keyBy(new KeySelector<AdClickLog, Tuple2<Long,Long>>() {
            @Override
            public Tuple2<Long, Long> getKey(AdClickLog value) throws Exception {
                return Tuple2.of(value.getUserId(),value.getAdId());
            }
        }).timeWindow(Time.hours(1),Time.minutes(5)).aggregate(new SimpleAggFunction<AdClickLog>(),new aggregateCount())
                .keyBy(r->r.getWindowEnd()).process(new topaN(3)).print();

        env.execute();
    }
    public static class  adFilter extends KeyedProcessFunction<Tuple2<Long, Long>,AdClickLog,AdClickLog>{
        private ValueState<Integer> adClick;
        private Long triggerTS=0L;
        OutputTag<String> output=new OutputTag<String>("blacklist"){};
        private ValueState<Boolean> flag;

        @Override
        public void open(Configuration parameters) throws Exception {
            adClick=getRuntimeContext().getState(new ValueStateDescriptor<Integer>("adClick",Integer.class,0));
            flag=getRuntimeContext().getState(new ValueStateDescriptor<Boolean>("flag",Boolean.class,false));
        }

        @Override
        public void processElement(AdClickLog value, Context context, Collector<AdClickLog> collector) throws Exception {
            if (triggerTS==0){
                Long timeDays=context.timestamp()/(24*60*60);
                Long nextDays=timeDays+1;
                triggerTS=nextDays*24*60*60;
                context.timerService().registerEventTimeTimer(triggerTS);
            }
            Integer clickCount = adClick.value();
            if (clickCount>=100){
                if (!flag.value()) {
                    context.output(output, "用户" + value.getUserId() + "点击了" + clickCount + "次" + value.getAdId() + "被恶意点击了");
                    flag.update(true);
                }
            }else {
                adClick.update(clickCount+1);
                collector.collect(value);
            }
        }

        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<AdClickLog> out) throws Exception {
            System.out.println(timestamp+"点击数清空");
            adClick.clear();
            System.out.println("触发时间清空"+timestamp+"adClick="+adClick.value());
            triggerTS=0L;
        }
    }
    public static class topaN extends KeyedProcessFunction<Long, HotAdClickbyUser,String>{
        private ListState<HotAdClickbyUser> listState;
        private ValueState<Long> triggerTS;
        private Integer threshold;

        public topaN(Integer threshold) {
            this.threshold = threshold;
        }

        @Override
        public void open(Configuration parameters) throws Exception {
            listState=getRuntimeContext().getListState(new ListStateDescriptor<HotAdClickbyUser>("hh",HotAdClickbyUser.class));
            triggerTS=getRuntimeContext().getState(new ValueStateDescriptor<Long>("aa",Long.class));
        }

        @Override
        public void processElement(HotAdClickbyUser value, Context context, Collector<String> collector) throws Exception {
                listState.add(value);
                if (triggerTS.value()==null){
                    context.timerService().registerEventTimeTimer(value.getWindowEnd());
                    triggerTS.update(value.getWindowEnd());
                }
        }

        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {
            List<HotAdClickbyUser> value = new ArrayList<>();
            Iterable<HotAdClickbyUser> datas = listState.get();
            for (HotAdClickbyUser data : datas) {
                value.add(data);
            }
            listState.clear();
            triggerTS.clear();
            value.sort(new Comparator<HotAdClickbyUser>() {
                @Override
                public int compare(HotAdClickbyUser o1, HotAdClickbyUser o2) {
                    return o2.getClickCount().intValue()-o1.getClickCount().intValue();
                }
            });
            StringBuilder result = new StringBuilder();
            result.append("结束时间"+timestamp+"\n")
            .append("-------------\n");
            threshold=threshold>value.size()?value.size():threshold;
            for (int i = 0; i < threshold; i++) {
                result.append(value.get(i)+"\n");
            }
            result.append("-------------\n");
            out.collect(result.toString());
        }
    }
    public static class aggregateCount extends ProcessWindowFunction<Long, HotAdClickbyUser,Tuple2<Long, Long>, TimeWindow>{

        @Override
        public void process(Tuple2<Long, Long> value, Context context, Iterable<Long> iterable, Collector<HotAdClickbyUser> collector) throws Exception {
            collector.collect(new HotAdClickbyUser(
                    value.f0,value.f1,iterable.iterator().next(),context.window().getEnd()
            ));
        }
    }

}


/**
 * @author weixu
 * @create 2020-09-24 16:21
 */
public class Flink30_Case_LoginDetect {
    public static void main(String[] args) throws Exception {
        // 0.创建执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.读取数据
        SingleOutputStreamOperator<LoginEvent> loginDS = env
                .readTextFile("input/LoginLog.csv")
                .map(new MapFunction<String, LoginEvent>() {
                    @Override
                    public LoginEvent map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new LoginEvent(
                                Long.valueOf(datas[0]),
                                datas[1],
                                datas[2],
                                Long.valueOf(datas[3])
                        );
                    }
                })
                .assignTimestampsAndWatermarks(
                        new BoundedOutOfOrdernessTimestampExtractor<LoginEvent>(Time.seconds(10)) {
                            @Override
                            public long extractTimestamp(LoginEvent element) {
                                return element.getEventTime() * 1000L;
                            }
                        }
                );


        //TODO
        // 1.不应该过滤 => 破坏了连续性
        // 2. 乱序场景下有问题 => 按照时间顺序是 F、F、S => 但是收到数据是 F、S、F
        // 3. 如果是 2s内 连续5次失败呢？

        // 2.处理数据
        // 2.1 过滤
        KeyedStream<LoginEvent, Long> loginEventKS = loginDS.filter(data -> "fail".equals(data.getEventType())).keyBy(datas -> datas.getUserId());
        // 2.3 分析是否恶意登陆
        loginEventKS.process(new LoginFailDetect()).print();


       env.execute();
    }
    public static class LoginFailDetect extends KeyedProcessFunction<Long,LoginEvent,String>{
        private ValueState<LoginEvent> loginZT;

        @Override
        public void open(Configuration parameters) throws Exception {
            loginZT=getRuntimeContext().getState(new ValueStateDescriptor<LoginEvent>("login",LoginEvent.class));

        }

        @Override
        public void processElement(LoginEvent value, Context context, Collector<String> collector) throws Exception {

            if (loginZT.value()==null){
                loginZT.update(value);
            }else {
                if (Math.abs(value.getEventTime()-loginZT.value().getEventTime())>=2){
                    collector.collect("用户" + value.getUserId() + "在2s内登陆失败2次，可能为恶意登陆！");
                }
                loginZT.update(value);
            }
        }
    }
}



/**
 * @author weixu
 * @create 2020-09-24 16:42
 */
public class Flink31_Case_OrderTimeoutDetect {
    public static void main(String[] args) throws Exception {
        // 0 执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1.读取数据，转成bean对象
        SingleOutputStreamOperator<OrderEvent> orderDS = env
                .readTextFile("input/OrderLog.csv")
                .map(new MapFunction<String, OrderEvent>() {
                    @Override
                    public OrderEvent map(String value) throws Exception {
                        String[] datas = value.split(",");
                        return new OrderEvent(
                                Long.valueOf(datas[0]),
                                datas[1],
                                datas[2],
                                Long.valueOf(datas[3])
                        );
                    }
                })
                .assignTimestampsAndWatermarks(
                        new AscendingTimestampExtractor<OrderEvent>() {
                            @Override
                            public long extractAscendingTimestamp(OrderEvent element) {
                                return element.getEventTime() * 1000L;
                            }
                        }
                );
//        订单超时监测
        SingleOutputStreamOperator<String> process = orderDS
                .keyBy(data -> data.getOrderId())
                .process(new OrderTimeoutDetect());
        process.print("order");
        OutputTag output =new OutputTag<String>("output"){};
        process.getSideOutput(output).print("output");

        env.execute();
    }
    public static class OrderTimeoutDetect extends KeyedProcessFunction<Long, OrderEvent, String> {
        private ValueState<OrderEvent> payState;
        private ValueState<OrderEvent> createState;
        private ValueState<Long> timeoutTs;
        OutputTag timeoutTag = new OutputTag<String>("timeout") {
        };

        @Override
        public void open(Configuration parameters) throws Exception {
            payState = getRuntimeContext().getState(new ValueStateDescriptor<OrderEvent>("payState", OrderEvent.class));
            createState = getRuntimeContext().getState(new ValueStateDescriptor<OrderEvent>("createState", OrderEvent.class));
            timeoutTs = getRuntimeContext().getState(new ValueStateDescriptor<Long>("timeoutTs", Long.class));
        }

        @Override
        public void processElement(OrderEvent value, Context ctx, Collector<String> out) throws Exception {
            // 还要考虑：只来一个数据的情况
            if (timeoutTs.value() == null) {
                // 这里不用考虑来的是create还是pay，统一都等15分钟
                ctx.timerService().registerEventTimeTimer(ctx.timestamp() + 15 * 60 * 1000L);
                timeoutTs.update(ctx.timestamp() + 15 * 60 * 1000L);
            } else {
                // 说明另一条数据来了，删除定时器
                ctx.timerService().deleteEventTimeTimer(timeoutTs.value());
                timeoutTs.clear();
            }

            // 数据可能是乱序的，对同一个订单而言，可能是 pay的数据先到
            // 判断一下当前来的是什么数据
            if ("create".equals(value.getEventType())) {
                // 1.说明当前数据是 create => 判断 pay是否来过
                if (payState.value() == null) {
                    // 1.1 pay没来过 => 把 create存起来
                    createState.update(value);
                } else {
                    // 1.2 pay来过 =》 判断是否超时
                    if (payState.value().getEventTime() - value.getEventTime() > 15 * 60) {
                        // 1.2.1 超时 => 告警
                        ctx.output(timeoutTag, "订单" + value.getOrderId() + "支付成功，但是超时，系统可能存在漏洞，请及时修复！！！");
                    } else {
                        // 1.2.2 没超时
                        out.collect("订单" + value.getOrderId() + "支付成功！");
                    }
                    // 使用完，清空
                    payState.clear();
                }
            } else {
                // 2.说明当前数据是 pay => 判断 create是否来过
                if (createState.value() == null) {
                    // 2.1 说明 create没来过 => 把当前的 pay存起来
                    payState.update(value);
                } else {
                    // 2.2 说明 create来过 => 判断是否超时
                    if (value.getEventTime() - createState.value().getEventTime() > 15 * 60) {
                        // 2.2.1 超时
                        ctx.output(timeoutTag, "订单" + value.getOrderId() + "支付成功，但是超时，系统可能存在漏洞，请及时修复！！！");
                    } else {
                        // 2.2.2 没超时
                        out.collect("订单" + value.getOrderId() + "支付成功！");
                    }
                    // 使用完，清空
                    createState.clear();
                }
            }
        }

        /**
         * 定时器触发：说明另一条数据没来
         * @param timestamp
         * @param ctx
         * @param out
         * @throws Exception
         */
        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {
            // 判断一下是谁没来
            // 如果是create没来 => 说明pay来过，说明payState不为空
            if (payState.value() != null){
                // create没来 => 异常情况，告警
                ctx.output(timeoutTag, "订单"+payState.value().getOrderId()+"有支付数据，但下单数据丢失，系统存在异常！！！");
                // 清空
                payState.clear();
            }
            // 如果是pay没来 => 说明create来过，说明createState不为空
            if (createState.value() != null){
                // pay没来 => 没支付
                ctx.output(timeoutTag,"订单"+createState.value().getOrderId()+"支付超时！！！" );
                // 清空
                createState.clear();
            }
            timeoutTs.clear();
        }
    }
}





